#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>
#include <ctime>
#include <cmath>

using namespace std;


// Coordinates of the generator point
long double YofG = 1;
long double XofG = 0;

// y^2 = x^3 + ax + b
int AofCurve = 1;
int BofCurve = 1;

long double Gradient;
long double Cx;
long double Cy;
long double Newx;
long double Newy;



long double PointDouble(int a, int b, long double *x, long double *y, long double xGen, long double yGen, long double nx, long double ny)
{
    // calculate the gradient through substituting values into the derivative
    Gradient = ((3*pow(xGen,2) + a)/2*yGen);

    // calculate coords of the new intersection with the elliptic curve
    nx = pow(Gradient, 2) - 2*xGen;
    ny = Gradient*(xGen - nx) - yGen;

    // set current x and y points to the newly determined points
    *x = nx;
    *y = ny;

}

long double PointAddition(long double xGen, long double yGen, long double *xOther, long double *yOther, long double nx, long double ny)
{
    // calculate the gradient between the points
    Gradient = (yGen - (*yOther))/(xGen - (*xOther));

    // calculate coords of the new intersection with the elliptic curve
    nx = pow(Gradient, 2) - xGen - (*xOther);
    ny = Gradient*(xGen - nx) - yGen;

    // set current x and y points to the newly determined points
    *xOther = nx;
    *yOther = ny;

}

long double ScalarPointMultiplication(int a, int b, long double xGen, long double yGen, long double *x, long double *y, long double nx, long double ny, int repetition)
{

    PointDouble(a, b, x, y, xGen, yGen, nx, ny);
    for (int i = 0; i < repetition; i++)
    {
        PointAddition(xGen, yGen, x, y, nx, ny);
    }
    
}


/* Upper random value <-- The random number would be handled by being 
                          generated by the pacemaker's sensitive data
                          on the heart rate of the patient          */
int UpperRandom = 500;

// Defining variables being used
long double PublicKey[2];
int RandomVariable;
long double Message[2];
long double Key1;
long double Key2;


// Generate random value function
void RandomNumberGeneration(int UpperRandom)
{
    srand(time(0));
    RandomVariable = rand() % UpperRandom;

    // inform of random variable
    cout << "Your randomly generated number is: " << RandomVariable << endl;
}

// Create transmitted message
void MessageCreator(long double nx, long double ny, long double *x, long double *y, int RandomVariable)
{
    ScalarPointMultiplication(AofCurve, BofCurve, XofG, YofG, x, y, nx, ny, RandomVariable);
    Message[0] = *x;
    Message[1] = *y;
    //Message = RandomVariable * GeneratorPoint; done above
    

    // Write coords to a file so that they are sent as a message
    const char *PATH="C:\\Pacemaker-Cryptosystem\\Code\\ECC Code\\ECC_input_files\\ECC_key_exchange_2.txt"; // NOTE: replace for your file path
    std::ofstream OutPutFile;
    OutPutFile.open(PATH, std::ios_base::app);
    OutPutFile << std::fixed << std::setprecision(37) << Message[0] << endl << Message[1];
    OutPutFile.close();


    // inform of transmitted message
    cout << "the message x transmitted is: " << Message[0] << endl;
    cout << "the message y transmitted is: " << Message[1] << endl;
}

// Create symmetric key using public key
void SymKeyPublicCreation(long double nx, long double ny, long double *x, long double *y, int RandomVariable)
{
    // Read file to obtain values for public keys
    // define path for input file
    const char *PATH="C:\\Pacemaker-Cryptosystem\\Code\\ECC Code\\ECC_input_files\\ECC_key_exchange_1.txt"; // NOTE: replace for your file path
    std::ifstream InPutFile;
    InPutFile.open(PATH);

    string temp_key_string;
    long double temp_key;

    for (int i = 0; i < 2; i++)
    {
        ( getline (InPutFile,temp_key_string) );
        temp_key = {stold(temp_key_string)};
        PublicKey[i] = temp_key;
    }
    InPutFile.close();


    *x = PublicKey[0];
    *y = PublicKey[1];

    for (int i = 0; i < RandomVariable; i++)
    {
        PointAddition(XofG, YofG, x, y, nx, ny);
    }

    long double SymmetricKeyPublic[2] = {*x, *y};
    //SymmetricKeyPublic = RandomVariable * PublicKey; done above


    // setting symkey to key 1
    Key1 = SymmetricKeyPublic[0];
    Key2 = SymmetricKeyPublic[1];

    // inform recipient of public key of their generated symmetric key
    cout << "the symmetric x key you have created but have kept hidden is: " << SymmetricKeyPublic[0] << endl;
    cout << "the symmetric y key you have created but have kept hidden is: " << SymmetricKeyPublic[1] << endl;
    cout << "NOTE, the above key is only known to the recipient of the public key" << endl;
}



// main function
int main()
{
    Cx = XofG;
    Cy = YofG;
    RandomNumberGeneration(UpperRandom);
    MessageCreator(Newx, Newy, &Cx, &Cy, RandomVariable);
    SymKeyPublicCreation(Newx, Newy, &Cx, &Cy, RandomVariable);

    // define path for file and output the x key to the file
    const char *PATH="C:\\Pacemaker-Cryptosystem\\Code\\AES Code\\AES_input_files\\key_exchange.txt"; // NOTE: replace for your file path
    std::ofstream OutPutFile;
    OutPutFile.open(PATH, std::ios_base::app);
    OutPutFile << std::fixed << std::setprecision(37) << Key1;
    cout << Key1 << endl;
    cout << Key2;
    
    return 0;
}